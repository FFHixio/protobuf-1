// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: types/types.proto

/*
	Package types is a generated protocol buffer package.

	It is generated from these files:
		types/types.proto

	It has these top-level messages:
		TestAllTypes
		NestedTestAllTypes
		ForeignMessage
		TestMap
*/
package types

import js "github.com/gopherjs/gopherjs/js"
import jspb "github.com/johanbrandhorst/protobuf/jspb"
import multitest2 "github.com/johanbrandhorst/protobuf/protoc-gen-gopherjs/test/multi"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion1

type ForeignEnum int

const (
	ForeignEnum_FOREIGN_UNSPECIFIED ForeignEnum = 0
	ForeignEnum_FOREIGN_FOO         ForeignEnum = 4
	ForeignEnum_FOREIGN_BAR         ForeignEnum = 5
	ForeignEnum_FOREIGN_BAZ         ForeignEnum = 6
)

var ForeignEnum_name = map[int]string{
	0: "FOREIGN_UNSPECIFIED",
	4: "FOREIGN_FOO",
	5: "FOREIGN_BAR",
	6: "FOREIGN_BAZ",
}
var ForeignEnum_value = map[string]int{
	"FOREIGN_UNSPECIFIED": 0,
	"FOREIGN_FOO":         4,
	"FOREIGN_BAR":         5,
	"FOREIGN_BAZ":         6,
}

func (x ForeignEnum) String() string {
	return ForeignEnum_name[int(x)]
}

type MapEnum int

const (
	MapEnum_MAP_ENUM_FOO MapEnum = 0
	MapEnum_MAP_ENUM_BAR MapEnum = 1
	MapEnum_MAP_ENUM_BAZ MapEnum = 2
)

var MapEnum_name = map[int]string{
	0: "MAP_ENUM_FOO",
	1: "MAP_ENUM_BAR",
	2: "MAP_ENUM_BAZ",
}
var MapEnum_value = map[string]int{
	"MAP_ENUM_FOO": 0,
	"MAP_ENUM_BAR": 1,
	"MAP_ENUM_BAZ": 2,
}

func (x MapEnum) String() string {
	return MapEnum_name[int(x)]
}

type TestAllTypes_NestedEnum int

const (
	TestAllTypes_NESTED_ENUM_UNSPECIFIED TestAllTypes_NestedEnum = 0
	TestAllTypes_FOO                     TestAllTypes_NestedEnum = 1
	TestAllTypes_BAR                     TestAllTypes_NestedEnum = 2
	TestAllTypes_BAZ                     TestAllTypes_NestedEnum = 3
	TestAllTypes_NEG                     TestAllTypes_NestedEnum = -1
)

var TestAllTypes_NestedEnum_name = map[int]string{
	0:  "NESTED_ENUM_UNSPECIFIED",
	1:  "FOO",
	2:  "BAR",
	3:  "BAZ",
	-1: "NEG",
}
var TestAllTypes_NestedEnum_value = map[string]int{
	"NESTED_ENUM_UNSPECIFIED": 0,
	"FOO": 1,
	"BAR": 2,
	"BAZ": 3,
	"NEG": -1,
}

func (x TestAllTypes_NestedEnum) String() string {
	return TestAllTypes_NestedEnum_name[int(x)]
}

// This proto includes every type of field in both singular and repeated
// forms.
type TestAllTypes struct {
	*js.Object
}

// For oneof test
//
// Types that are valid to be assigned to OneofField:
//	*TestAllTypes_OneofUint32
//	*TestAllTypes_OneofNestedMessage
//	*TestAllTypes_OneofString
//	*TestAllTypes_OneofBytes
//	*TestAllTypes_OneofImportedMessage
type isTestAllTypes_OneofField interface {
	isTestAllTypes_OneofField()
}

type TestAllTypes_OneofUint32 struct {
	OneofUint32 uint32
}
type TestAllTypes_OneofNestedMessage struct {
	OneofNestedMessage *TestAllTypes_NestedMessage
}
type TestAllTypes_OneofString struct {
	OneofString string
}
type TestAllTypes_OneofBytes struct {
	OneofBytes []byte
}
type TestAllTypes_OneofImportedMessage struct {
	OneofImportedMessage *multitest2.Multi1
}

func (*TestAllTypes_OneofUint32) isTestAllTypes_OneofField()          {}
func (*TestAllTypes_OneofNestedMessage) isTestAllTypes_OneofField()   {}
func (*TestAllTypes_OneofString) isTestAllTypes_OneofField()          {}
func (*TestAllTypes_OneofBytes) isTestAllTypes_OneofField()           {}
func (*TestAllTypes_OneofImportedMessage) isTestAllTypes_OneofField() {}

// GetOneofField gets the OneofField of the TestAllTypes.
func (m *TestAllTypes) GetOneofField() (x isTestAllTypes_OneofField) {
	switch m.Call("getOneofFieldCase").Int() {
	case 111:
		x = &TestAllTypes_OneofUint32{
			OneofUint32: m.GetOneofUint32(),
		}
	case 112:
		x = &TestAllTypes_OneofNestedMessage{
			OneofNestedMessage: m.GetOneofNestedMessage(),
		}
	case 113:
		x = &TestAllTypes_OneofString{
			OneofString: m.GetOneofString(),
		}
	case 114:
		x = &TestAllTypes_OneofBytes{
			OneofBytes: m.GetOneofBytes(),
		}
	case 115:
		x = &TestAllTypes_OneofImportedMessage{
			OneofImportedMessage: m.GetOneofImportedMessage(),
		}
	}

	return x
}

// SetOneofField sets the OneofField of theTestAllTypes.
// If the input is nil, SetOneofField does nothing.
func (m *TestAllTypes) SetOneofField(oneof_field isTestAllTypes_OneofField) {
	switch x := oneof_field.(type) {
	case *TestAllTypes_OneofUint32:
		m.SetOneofUint32(x.OneofUint32)
	case *TestAllTypes_OneofNestedMessage:
		m.SetOneofNestedMessage(x.OneofNestedMessage)
	case *TestAllTypes_OneofString:
		m.SetOneofString(x.OneofString)
	case *TestAllTypes_OneofBytes:
		m.SetOneofBytes(x.OneofBytes)
	case *TestAllTypes_OneofImportedMessage:
		m.SetOneofImportedMessage(x.OneofImportedMessage)
	}
}

// GetSingleInt32 gets the SingleInt32 of the TestAllTypes.
// Singular
func (m *TestAllTypes) GetSingleInt32() (x int32) {
	if m == nil {
		return x
	}
	return int32(m.Call("getSingleInt32").Int())
}

// SetSingleInt32 sets the SingleInt32 of the TestAllTypes.
// Singular
func (m *TestAllTypes) SetSingleInt32(v int32) {
	m.Call("setSingleInt32", v)
}

// GetSingleInt64 gets the SingleInt64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleInt64() (x int64) {
	if m == nil {
		return x
	}
	return m.Call("getSingleInt64").Int64()
}

// SetSingleInt64 sets the SingleInt64 of the TestAllTypes.
func (m *TestAllTypes) SetSingleInt64(v int64) {
	m.Call("setSingleInt64", v)
}

// GetSingleUint32 gets the SingleUint32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleUint32() (x uint32) {
	if m == nil {
		return x
	}
	return uint32(m.Call("getSingleUint32").Int())
}

// SetSingleUint32 sets the SingleUint32 of the TestAllTypes.
func (m *TestAllTypes) SetSingleUint32(v uint32) {
	m.Call("setSingleUint32", v)
}

// GetSingleUint64 gets the SingleUint64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleUint64() (x uint64) {
	if m == nil {
		return x
	}
	return m.Call("getSingleUint64").Uint64()
}

// SetSingleUint64 sets the SingleUint64 of the TestAllTypes.
func (m *TestAllTypes) SetSingleUint64(v uint64) {
	m.Call("setSingleUint64", v)
}

// GetSingleSint32 gets the SingleSint32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleSint32() (x int32) {
	if m == nil {
		return x
	}
	return int32(m.Call("getSingleSint32").Int())
}

// SetSingleSint32 sets the SingleSint32 of the TestAllTypes.
func (m *TestAllTypes) SetSingleSint32(v int32) {
	m.Call("setSingleSint32", v)
}

// GetSingleSint64 gets the SingleSint64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleSint64() (x int64) {
	if m == nil {
		return x
	}
	return m.Call("getSingleSint64").Int64()
}

// SetSingleSint64 sets the SingleSint64 of the TestAllTypes.
func (m *TestAllTypes) SetSingleSint64(v int64) {
	m.Call("setSingleSint64", v)
}

// GetSingleFixed32 gets the SingleFixed32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleFixed32() (x uint32) {
	if m == nil {
		return x
	}
	return uint32(m.Call("getSingleFixed32").Int())
}

// SetSingleFixed32 sets the SingleFixed32 of the TestAllTypes.
func (m *TestAllTypes) SetSingleFixed32(v uint32) {
	m.Call("setSingleFixed32", v)
}

// GetSingleFixed64 gets the SingleFixed64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleFixed64() (x uint64) {
	if m == nil {
		return x
	}
	return m.Call("getSingleFixed64").Uint64()
}

// SetSingleFixed64 sets the SingleFixed64 of the TestAllTypes.
func (m *TestAllTypes) SetSingleFixed64(v uint64) {
	m.Call("setSingleFixed64", v)
}

// GetSingleSfixed32 gets the SingleSfixed32 of the TestAllTypes.
func (m *TestAllTypes) GetSingleSfixed32() (x int32) {
	if m == nil {
		return x
	}
	return int32(m.Call("getSingleSfixed32").Int())
}

// SetSingleSfixed32 sets the SingleSfixed32 of the TestAllTypes.
func (m *TestAllTypes) SetSingleSfixed32(v int32) {
	m.Call("setSingleSfixed32", v)
}

// GetSingleSfixed64 gets the SingleSfixed64 of the TestAllTypes.
func (m *TestAllTypes) GetSingleSfixed64() (x int64) {
	if m == nil {
		return x
	}
	return m.Call("getSingleSfixed64").Int64()
}

// SetSingleSfixed64 sets the SingleSfixed64 of the TestAllTypes.
func (m *TestAllTypes) SetSingleSfixed64(v int64) {
	m.Call("setSingleSfixed64", v)
}

// GetSingleFloat gets the SingleFloat of the TestAllTypes.
func (m *TestAllTypes) GetSingleFloat() (x float32) {
	if m == nil {
		return x
	}
	return float32(m.Call("getSingleFloat").Float())
}

// SetSingleFloat sets the SingleFloat of the TestAllTypes.
func (m *TestAllTypes) SetSingleFloat(v float32) {
	m.Call("setSingleFloat", v)
}

// GetSingleDouble gets the SingleDouble of the TestAllTypes.
func (m *TestAllTypes) GetSingleDouble() (x float64) {
	if m == nil {
		return x
	}
	return m.Call("getSingleDouble").Float()
}

// SetSingleDouble sets the SingleDouble of the TestAllTypes.
func (m *TestAllTypes) SetSingleDouble(v float64) {
	m.Call("setSingleDouble", v)
}

// GetSingleBool gets the SingleBool of the TestAllTypes.
func (m *TestAllTypes) GetSingleBool() (x bool) {
	if m == nil {
		return x
	}
	return m.Call("getSingleBool").Bool()
}

// SetSingleBool sets the SingleBool of the TestAllTypes.
func (m *TestAllTypes) SetSingleBool(v bool) {
	m.Call("setSingleBool", v)
}

// GetSingleString gets the SingleString of the TestAllTypes.
func (m *TestAllTypes) GetSingleString() (x string) {
	if m == nil {
		return x
	}
	return m.Call("getSingleString").String()
}

// SetSingleString sets the SingleString of the TestAllTypes.
func (m *TestAllTypes) SetSingleString(v string) {
	m.Call("setSingleString", v)
}

// GetSingleBytes gets the SingleBytes of the TestAllTypes.
func (m *TestAllTypes) GetSingleBytes() (x []byte) {
	if m == nil {
		return x
	}
	return m.Call("getSingleBytes_asU8").Interface().([]byte)
}

// SetSingleBytes sets the SingleBytes of the TestAllTypes.
func (m *TestAllTypes) SetSingleBytes(v []byte) {
	m.Call("setSingleBytes", v)
}

// GetSingleImportedMessage gets the SingleImportedMessage of the TestAllTypes.
func (m *TestAllTypes) GetSingleImportedMessage() (x *multitest2.Multi1) {
	if m == nil {
		return x
	}
	return &multitest2.Multi1{Object: m.Call("getSingleImportedMessage")}
}

// SetSingleImportedMessage sets the SingleImportedMessage of the TestAllTypes.
func (m *TestAllTypes) SetSingleImportedMessage(v *multitest2.Multi1) {
	if v != nil {
		m.Call("setSingleImportedMessage", v)
	} else {
		m.ClearSingleImportedMessage()
	}
}

// HasSingleImportedMessage indicates whether the SingleImportedMessage of the TestAllTypes is set.
func (m *TestAllTypes) HasSingleImportedMessage() bool {
	if m == nil {
		return false
	}
	return m.Call("hasSingleImportedMessage").Bool()
}

// ClearSingleImportedMessage clears the SingleImportedMessage of the TestAllTypes.
func (m *TestAllTypes) ClearSingleImportedMessage() {
	m.Call("clearSingleImportedMessage")
}

// GetSingleNestedMessage gets the SingleNestedMessage of the TestAllTypes.
func (m *TestAllTypes) GetSingleNestedMessage() (x *TestAllTypes_NestedMessage) {
	if m == nil {
		return x
	}
	return &TestAllTypes_NestedMessage{Object: m.Call("getSingleNestedMessage")}
}

// SetSingleNestedMessage sets the SingleNestedMessage of the TestAllTypes.
func (m *TestAllTypes) SetSingleNestedMessage(v *TestAllTypes_NestedMessage) {
	if v != nil {
		m.Call("setSingleNestedMessage", v)
	} else {
		m.ClearSingleNestedMessage()
	}
}

// HasSingleNestedMessage indicates whether the SingleNestedMessage of the TestAllTypes is set.
func (m *TestAllTypes) HasSingleNestedMessage() bool {
	if m == nil {
		return false
	}
	return m.Call("hasSingleNestedMessage").Bool()
}

// ClearSingleNestedMessage clears the SingleNestedMessage of the TestAllTypes.
func (m *TestAllTypes) ClearSingleNestedMessage() {
	m.Call("clearSingleNestedMessage")
}

// GetSingleForeignMessage gets the SingleForeignMessage of the TestAllTypes.
func (m *TestAllTypes) GetSingleForeignMessage() (x *ForeignMessage) {
	if m == nil {
		return x
	}
	return &ForeignMessage{Object: m.Call("getSingleForeignMessage")}
}

// SetSingleForeignMessage sets the SingleForeignMessage of the TestAllTypes.
func (m *TestAllTypes) SetSingleForeignMessage(v *ForeignMessage) {
	if v != nil {
		m.Call("setSingleForeignMessage", v)
	} else {
		m.ClearSingleForeignMessage()
	}
}

// HasSingleForeignMessage indicates whether the SingleForeignMessage of the TestAllTypes is set.
func (m *TestAllTypes) HasSingleForeignMessage() bool {
	if m == nil {
		return false
	}
	return m.Call("hasSingleForeignMessage").Bool()
}

// ClearSingleForeignMessage clears the SingleForeignMessage of the TestAllTypes.
func (m *TestAllTypes) ClearSingleForeignMessage() {
	m.Call("clearSingleForeignMessage")
}

// GetSingleNestedEnum gets the SingleNestedEnum of the TestAllTypes.
func (m *TestAllTypes) GetSingleNestedEnum() (x TestAllTypes_NestedEnum) {
	if m == nil {
		return x
	}
	return TestAllTypes_NestedEnum(m.Call("getSingleNestedEnum").Int())
}

// SetSingleNestedEnum sets the SingleNestedEnum of the TestAllTypes.
func (m *TestAllTypes) SetSingleNestedEnum(v TestAllTypes_NestedEnum) {
	m.Call("setSingleNestedEnum", v)
}

// GetSingleForeignEnum gets the SingleForeignEnum of the TestAllTypes.
func (m *TestAllTypes) GetSingleForeignEnum() (x ForeignEnum) {
	if m == nil {
		return x
	}
	return ForeignEnum(m.Call("getSingleForeignEnum").Int())
}

// SetSingleForeignEnum sets the SingleForeignEnum of the TestAllTypes.
func (m *TestAllTypes) SetSingleForeignEnum(v ForeignEnum) {
	m.Call("setSingleForeignEnum", v)
}

// GetRepeatedInt32 gets the RepeatedInt32 of the TestAllTypes.
// Repeated
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedInt32() (x []int32) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, int32(value.Int()))
	}
	m.Call("getRepeatedInt32List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedInt32 sets the RepeatedInt32 of the TestAllTypes.
// Repeated
func (m *TestAllTypes) SetRepeatedInt32(v []int32) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedInt32List", arr)
}

// AddRepeatedInt32 adds an entry to the RepeatedInt32 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
// Repeated
func (m *TestAllTypes) AddRepeatedInt32(v int32, index int) {
	m.Call("addRepeatedInt32", v, index)
}

// ClearRepeatedInt32 clears the RepeatedInt32 of the TestAllTypes.
// Repeated
func (m *TestAllTypes) ClearRepeatedInt32() {
	m.Call("clearRepeatedInt32List")
}

// GetRepeatedInt64 gets the RepeatedInt64 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedInt64() (x []int64) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.Int64())
	}
	m.Call("getRepeatedInt64List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedInt64 sets the RepeatedInt64 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedInt64(v []int64) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedInt64List", arr)
}

// AddRepeatedInt64 adds an entry to the RepeatedInt64 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedInt64(v int64, index int) {
	m.Call("addRepeatedInt64", v, index)
}

// ClearRepeatedInt64 clears the RepeatedInt64 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedInt64() {
	m.Call("clearRepeatedInt64List")
}

// GetRepeatedUint32 gets the RepeatedUint32 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedUint32() (x []uint32) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, uint32(value.Int()))
	}
	m.Call("getRepeatedUint32List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedUint32 sets the RepeatedUint32 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedUint32(v []uint32) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedUint32List", arr)
}

// AddRepeatedUint32 adds an entry to the RepeatedUint32 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedUint32(v uint32, index int) {
	m.Call("addRepeatedUint32", v, index)
}

// ClearRepeatedUint32 clears the RepeatedUint32 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedUint32() {
	m.Call("clearRepeatedUint32List")
}

// GetRepeatedUint64 gets the RepeatedUint64 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedUint64() (x []uint64) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.Uint64())
	}
	m.Call("getRepeatedUint64List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedUint64 sets the RepeatedUint64 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedUint64(v []uint64) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedUint64List", arr)
}

// AddRepeatedUint64 adds an entry to the RepeatedUint64 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedUint64(v uint64, index int) {
	m.Call("addRepeatedUint64", v, index)
}

// ClearRepeatedUint64 clears the RepeatedUint64 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedUint64() {
	m.Call("clearRepeatedUint64List")
}

// GetRepeatedSint32 gets the RepeatedSint32 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedSint32() (x []int32) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, int32(value.Int()))
	}
	m.Call("getRepeatedSint32List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedSint32 sets the RepeatedSint32 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedSint32(v []int32) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedSint32List", arr)
}

// AddRepeatedSint32 adds an entry to the RepeatedSint32 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedSint32(v int32, index int) {
	m.Call("addRepeatedSint32", v, index)
}

// ClearRepeatedSint32 clears the RepeatedSint32 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedSint32() {
	m.Call("clearRepeatedSint32List")
}

// GetRepeatedSint64 gets the RepeatedSint64 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedSint64() (x []int64) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.Int64())
	}
	m.Call("getRepeatedSint64List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedSint64 sets the RepeatedSint64 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedSint64(v []int64) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedSint64List", arr)
}

// AddRepeatedSint64 adds an entry to the RepeatedSint64 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedSint64(v int64, index int) {
	m.Call("addRepeatedSint64", v, index)
}

// ClearRepeatedSint64 clears the RepeatedSint64 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedSint64() {
	m.Call("clearRepeatedSint64List")
}

// GetRepeatedFixed32 gets the RepeatedFixed32 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedFixed32() (x []uint32) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, uint32(value.Int()))
	}
	m.Call("getRepeatedFixed32List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedFixed32 sets the RepeatedFixed32 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedFixed32(v []uint32) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedFixed32List", arr)
}

// AddRepeatedFixed32 adds an entry to the RepeatedFixed32 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedFixed32(v uint32, index int) {
	m.Call("addRepeatedFixed32", v, index)
}

// ClearRepeatedFixed32 clears the RepeatedFixed32 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedFixed32() {
	m.Call("clearRepeatedFixed32List")
}

// GetRepeatedFixed64 gets the RepeatedFixed64 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedFixed64() (x []uint64) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.Uint64())
	}
	m.Call("getRepeatedFixed64List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedFixed64 sets the RepeatedFixed64 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedFixed64(v []uint64) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedFixed64List", arr)
}

// AddRepeatedFixed64 adds an entry to the RepeatedFixed64 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedFixed64(v uint64, index int) {
	m.Call("addRepeatedFixed64", v, index)
}

// ClearRepeatedFixed64 clears the RepeatedFixed64 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedFixed64() {
	m.Call("clearRepeatedFixed64List")
}

// GetRepeatedSfixed32 gets the RepeatedSfixed32 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedSfixed32() (x []int32) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, int32(value.Int()))
	}
	m.Call("getRepeatedSfixed32List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedSfixed32 sets the RepeatedSfixed32 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedSfixed32(v []int32) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedSfixed32List", arr)
}

// AddRepeatedSfixed32 adds an entry to the RepeatedSfixed32 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedSfixed32(v int32, index int) {
	m.Call("addRepeatedSfixed32", v, index)
}

// ClearRepeatedSfixed32 clears the RepeatedSfixed32 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedSfixed32() {
	m.Call("clearRepeatedSfixed32List")
}

// GetRepeatedSfixed64 gets the RepeatedSfixed64 of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedSfixed64() (x []int64) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.Int64())
	}
	m.Call("getRepeatedSfixed64List").Call("forEach", arrFunc)
	return x
}

// SetRepeatedSfixed64 sets the RepeatedSfixed64 of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedSfixed64(v []int64) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedSfixed64List", arr)
}

// AddRepeatedSfixed64 adds an entry to the RepeatedSfixed64 slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedSfixed64(v int64, index int) {
	m.Call("addRepeatedSfixed64", v, index)
}

// ClearRepeatedSfixed64 clears the RepeatedSfixed64 of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedSfixed64() {
	m.Call("clearRepeatedSfixed64List")
}

// GetRepeatedFloat gets the RepeatedFloat of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedFloat() (x []float32) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, float32(value.Float()))
	}
	m.Call("getRepeatedFloatList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedFloat sets the RepeatedFloat of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedFloat(v []float32) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedFloatList", arr)
}

// AddRepeatedFloat adds an entry to the RepeatedFloat slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedFloat(v float32, index int) {
	m.Call("addRepeatedFloat", v, index)
}

// ClearRepeatedFloat clears the RepeatedFloat of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedFloat() {
	m.Call("clearRepeatedFloatList")
}

// GetRepeatedDouble gets the RepeatedDouble of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedDouble() (x []float64) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.Float())
	}
	m.Call("getRepeatedDoubleList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedDouble sets the RepeatedDouble of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedDouble(v []float64) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedDoubleList", arr)
}

// AddRepeatedDouble adds an entry to the RepeatedDouble slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedDouble(v float64, index int) {
	m.Call("addRepeatedDouble", v, index)
}

// ClearRepeatedDouble clears the RepeatedDouble of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedDouble() {
	m.Call("clearRepeatedDoubleList")
}

// GetRepeatedBool gets the RepeatedBool of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedBool() (x []bool) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.Bool())
	}
	m.Call("getRepeatedBoolList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedBool sets the RepeatedBool of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedBool(v []bool) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedBoolList", arr)
}

// AddRepeatedBool adds an entry to the RepeatedBool slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedBool(v bool, index int) {
	m.Call("addRepeatedBool", v, index)
}

// ClearRepeatedBool clears the RepeatedBool of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedBool() {
	m.Call("clearRepeatedBoolList")
}

// GetRepeatedString gets the RepeatedString of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedString() (x []string) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.String())
	}
	m.Call("getRepeatedStringList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedString sets the RepeatedString of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedString(v []string) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedStringList", arr)
}

// AddRepeatedString adds an entry to the RepeatedString slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedString(v string, index int) {
	m.Call("addRepeatedString", v, index)
}

// ClearRepeatedString clears the RepeatedString of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedString() {
	m.Call("clearRepeatedStringList")
}

// GetRepeatedBytes gets the RepeatedBytes of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedBytes() (x [][]byte) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, value.Interface().([]byte))
	}
	m.Call("getRepeatedBytesList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedBytes sets the RepeatedBytes of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedBytes(v [][]byte) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedBytesList", arr)
}

// AddRepeatedBytes adds an entry to the RepeatedBytes slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedBytes(v []byte, index int) {
	m.Call("addRepeatedBytes", v, index)
}

// ClearRepeatedBytes clears the RepeatedBytes of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedBytes() {
	m.Call("clearRepeatedBytesList")
}

// GetRepeatedImportedMessage gets the RepeatedImportedMessage of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedImportedMessage() (x []*multitest2.Multi1) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, &multitest2.Multi1{Object: value})
	}
	m.Call("getRepeatedImportedMessageList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedImportedMessage sets the RepeatedImportedMessage of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedImportedMessage(v []*multitest2.Multi1) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedImportedMessageList", arr)
}

// AddRepeatedImportedMessage adds an entry to the RepeatedImportedMessage slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedImportedMessage(v *multitest2.Multi1, index int) {
	m.Call("addRepeatedImportedMessage", v, index)
}

// ClearRepeatedImportedMessage clears the RepeatedImportedMessage of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedImportedMessage() {
	m.Call("clearRepeatedImportedMessageList")
}

// GetRepeatedNestedMessage gets the RepeatedNestedMessage of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedNestedMessage() (x []*TestAllTypes_NestedMessage) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, &TestAllTypes_NestedMessage{Object: value})
	}
	m.Call("getRepeatedNestedMessageList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedNestedMessage sets the RepeatedNestedMessage of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedNestedMessage(v []*TestAllTypes_NestedMessage) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedNestedMessageList", arr)
}

// AddRepeatedNestedMessage adds an entry to the RepeatedNestedMessage slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedNestedMessage(v *TestAllTypes_NestedMessage, index int) {
	m.Call("addRepeatedNestedMessage", v, index)
}

// ClearRepeatedNestedMessage clears the RepeatedNestedMessage of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedNestedMessage() {
	m.Call("clearRepeatedNestedMessageList")
}

// GetRepeatedForeignMessage gets the RepeatedForeignMessage of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedForeignMessage() (x []*ForeignMessage) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, &ForeignMessage{Object: value})
	}
	m.Call("getRepeatedForeignMessageList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedForeignMessage sets the RepeatedForeignMessage of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedForeignMessage(v []*ForeignMessage) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedForeignMessageList", arr)
}

// AddRepeatedForeignMessage adds an entry to the RepeatedForeignMessage slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedForeignMessage(v *ForeignMessage, index int) {
	m.Call("addRepeatedForeignMessage", v, index)
}

// ClearRepeatedForeignMessage clears the RepeatedForeignMessage of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedForeignMessage() {
	m.Call("clearRepeatedForeignMessageList")
}

// GetRepeatedNestedEnum gets the RepeatedNestedEnum of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedNestedEnum() (x []TestAllTypes_NestedEnum) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, TestAllTypes_NestedEnum(value.Int()))
	}
	m.Call("getRepeatedNestedEnumList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedNestedEnum sets the RepeatedNestedEnum of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedNestedEnum(v []TestAllTypes_NestedEnum) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedNestedEnumList", arr)
}

// AddRepeatedNestedEnum adds an entry to the RepeatedNestedEnum slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedNestedEnum(v TestAllTypes_NestedEnum, index int) {
	m.Call("addRepeatedNestedEnum", v, index)
}

// ClearRepeatedNestedEnum clears the RepeatedNestedEnum of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedNestedEnum() {
	m.Call("clearRepeatedNestedEnumList")
}

// GetRepeatedForeignEnum gets the RepeatedForeignEnum of the TestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *TestAllTypes) GetRepeatedForeignEnum() (x []ForeignEnum) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, ForeignEnum(value.Int()))
	}
	m.Call("getRepeatedForeignEnumList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedForeignEnum sets the RepeatedForeignEnum of the TestAllTypes.
func (m *TestAllTypes) SetRepeatedForeignEnum(v []ForeignEnum) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedForeignEnumList", arr)
}

// AddRepeatedForeignEnum adds an entry to the RepeatedForeignEnum slice of the TestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *TestAllTypes) AddRepeatedForeignEnum(v ForeignEnum, index int) {
	m.Call("addRepeatedForeignEnum", v, index)
}

// ClearRepeatedForeignEnum clears the RepeatedForeignEnum of the TestAllTypes.
func (m *TestAllTypes) ClearRepeatedForeignEnum() {
	m.Call("clearRepeatedForeignEnumList")
}

// GetOneofUint32 gets the OneofUint32 of the TestAllTypes.
func (m *TestAllTypes) GetOneofUint32() (x uint32) {
	if m == nil {
		return x
	}
	return uint32(m.Call("getOneofUint32").Int())
}

// SetOneofUint32 sets the OneofUint32 of the TestAllTypes.
func (m *TestAllTypes) SetOneofUint32(v uint32) {
	m.Call("setOneofUint32", v)
}

// HasOneofUint32 indicates whether the OneofUint32 of the TestAllTypes is set.
func (m *TestAllTypes) HasOneofUint32() bool {
	if m == nil {
		return false
	}
	return m.Call("hasOneofUint32").Bool()
}

// ClearOneofUint32 clears the OneofUint32 of the TestAllTypes.
func (m *TestAllTypes) ClearOneofUint32() {
	m.Call("clearOneofUint32")
}

// GetOneofNestedMessage gets the OneofNestedMessage of the TestAllTypes.
func (m *TestAllTypes) GetOneofNestedMessage() (x *TestAllTypes_NestedMessage) {
	if m == nil {
		return x
	}
	return &TestAllTypes_NestedMessage{Object: m.Call("getOneofNestedMessage")}
}

// SetOneofNestedMessage sets the OneofNestedMessage of the TestAllTypes.
func (m *TestAllTypes) SetOneofNestedMessage(v *TestAllTypes_NestedMessage) {
	if v != nil {
		m.Call("setOneofNestedMessage", v)
	} else {
		m.ClearOneofNestedMessage()
	}
}

// HasOneofNestedMessage indicates whether the OneofNestedMessage of the TestAllTypes is set.
func (m *TestAllTypes) HasOneofNestedMessage() bool {
	if m == nil {
		return false
	}
	return m.Call("hasOneofNestedMessage").Bool()
}

// ClearOneofNestedMessage clears the OneofNestedMessage of the TestAllTypes.
func (m *TestAllTypes) ClearOneofNestedMessage() {
	m.Call("clearOneofNestedMessage")
}

// GetOneofString gets the OneofString of the TestAllTypes.
func (m *TestAllTypes) GetOneofString() (x string) {
	if m == nil {
		return x
	}
	return m.Call("getOneofString").String()
}

// SetOneofString sets the OneofString of the TestAllTypes.
func (m *TestAllTypes) SetOneofString(v string) {
	m.Call("setOneofString", v)
}

// HasOneofString indicates whether the OneofString of the TestAllTypes is set.
func (m *TestAllTypes) HasOneofString() bool {
	if m == nil {
		return false
	}
	return m.Call("hasOneofString").Bool()
}

// ClearOneofString clears the OneofString of the TestAllTypes.
func (m *TestAllTypes) ClearOneofString() {
	m.Call("clearOneofString")
}

// GetOneofBytes gets the OneofBytes of the TestAllTypes.
func (m *TestAllTypes) GetOneofBytes() (x []byte) {
	if m == nil {
		return x
	}
	return m.Call("getOneofBytes_asU8").Interface().([]byte)
}

// SetOneofBytes sets the OneofBytes of the TestAllTypes.
func (m *TestAllTypes) SetOneofBytes(v []byte) {
	m.Call("setOneofBytes", v)
}

// HasOneofBytes indicates whether the OneofBytes of the TestAllTypes is set.
func (m *TestAllTypes) HasOneofBytes() bool {
	if m == nil {
		return false
	}
	return m.Call("hasOneofBytes").Bool()
}

// ClearOneofBytes clears the OneofBytes of the TestAllTypes.
func (m *TestAllTypes) ClearOneofBytes() {
	m.Call("clearOneofBytes")
}

// GetOneofImportedMessage gets the OneofImportedMessage of the TestAllTypes.
func (m *TestAllTypes) GetOneofImportedMessage() (x *multitest2.Multi1) {
	if m == nil {
		return x
	}
	return &multitest2.Multi1{Object: m.Call("getOneofImportedMessage")}
}

// SetOneofImportedMessage sets the OneofImportedMessage of the TestAllTypes.
func (m *TestAllTypes) SetOneofImportedMessage(v *multitest2.Multi1) {
	if v != nil {
		m.Call("setOneofImportedMessage", v)
	} else {
		m.ClearOneofImportedMessage()
	}
}

// HasOneofImportedMessage indicates whether the OneofImportedMessage of the TestAllTypes is set.
func (m *TestAllTypes) HasOneofImportedMessage() bool {
	if m == nil {
		return false
	}
	return m.Call("hasOneofImportedMessage").Bool()
}

// ClearOneofImportedMessage clears the OneofImportedMessage of the TestAllTypes.
func (m *TestAllTypes) ClearOneofImportedMessage() {
	m.Call("clearOneofImportedMessage")
}

// New creates a new TestAllTypes.
// Singular
// Repeated
func (m *TestAllTypes) New(singleInt32 int32, singleInt64 int64, singleUint32 uint32, singleUint64 uint64, singleSint32 int32, singleSint64 int64, singleFixed32 uint32, singleFixed64 uint64, singleSfixed32 int32, singleSfixed64 int64, singleFloat float32, singleDouble float64, singleBool bool, singleString string, singleBytes []byte, singleImportedMessage *multitest2.Multi1, singleNestedMessage *TestAllTypes_NestedMessage, singleForeignMessage *ForeignMessage, singleNestedEnum TestAllTypes_NestedEnum, singleForeignEnum ForeignEnum, repeatedInt32 []int32, repeatedInt64 []int64, repeatedUint32 []uint32, repeatedUint64 []uint64, repeatedSint32 []int32, repeatedSint64 []int64, repeatedFixed32 []uint32, repeatedFixed64 []uint64, repeatedSfixed32 []int32, repeatedSfixed64 []int64, repeatedFloat []float32, repeatedDouble []float64, repeatedBool []bool, repeatedString []string, repeatedBytes [][]byte, repeatedImportedMessage []*multitest2.Multi1, repeatedNestedMessage []*TestAllTypes_NestedMessage, repeatedForeignMessage []*ForeignMessage, repeatedNestedEnum []TestAllTypes_NestedEnum, repeatedForeignEnum []ForeignEnum, oneof_field isTestAllTypes_OneofField) *TestAllTypes {
	m = &TestAllTypes{
		Object: js.Global.Get("proto").Get("types").Get("TestAllTypes").New([]interface{}{
			singleInt32,
			singleInt64,
			singleUint32,
			singleUint64,
			singleSint32,
			singleSint64,
			singleFixed32,
			singleFixed64,
			singleSfixed32,
			singleSfixed64,
			singleFloat,
			singleDouble,
			singleBool,
			singleString,
			singleBytes,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			singleNestedEnum,
			singleForeignEnum,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
		}),
	}

	m.SetOneofField(oneof_field)

	m.SetSingleImportedMessage(singleImportedMessage)

	m.SetSingleNestedMessage(singleNestedMessage)

	m.SetSingleForeignMessage(singleForeignMessage)

	arr := js.Global.Get("Array").New(len(repeatedInt32))
	for i, value := range repeatedInt32 {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedInt32List", arr)

	arr_ := js.Global.Get("Array").New(len(repeatedInt64))
	for i, value := range repeatedInt64 {
		arr_.SetIndex(i, value)
	}
	m.Call("setRepeatedInt64List", arr_)

	arr__ := js.Global.Get("Array").New(len(repeatedUint32))
	for i, value := range repeatedUint32 {
		arr__.SetIndex(i, value)
	}
	m.Call("setRepeatedUint32List", arr__)

	arr___ := js.Global.Get("Array").New(len(repeatedUint64))
	for i, value := range repeatedUint64 {
		arr___.SetIndex(i, value)
	}
	m.Call("setRepeatedUint64List", arr___)

	arr____ := js.Global.Get("Array").New(len(repeatedSint32))
	for i, value := range repeatedSint32 {
		arr____.SetIndex(i, value)
	}
	m.Call("setRepeatedSint32List", arr____)

	arr_____ := js.Global.Get("Array").New(len(repeatedSint64))
	for i, value := range repeatedSint64 {
		arr_____.SetIndex(i, value)
	}
	m.Call("setRepeatedSint64List", arr_____)

	arr______ := js.Global.Get("Array").New(len(repeatedFixed32))
	for i, value := range repeatedFixed32 {
		arr______.SetIndex(i, value)
	}
	m.Call("setRepeatedFixed32List", arr______)

	arr_______ := js.Global.Get("Array").New(len(repeatedFixed64))
	for i, value := range repeatedFixed64 {
		arr_______.SetIndex(i, value)
	}
	m.Call("setRepeatedFixed64List", arr_______)

	arr________ := js.Global.Get("Array").New(len(repeatedSfixed32))
	for i, value := range repeatedSfixed32 {
		arr________.SetIndex(i, value)
	}
	m.Call("setRepeatedSfixed32List", arr________)

	arr_________ := js.Global.Get("Array").New(len(repeatedSfixed64))
	for i, value := range repeatedSfixed64 {
		arr_________.SetIndex(i, value)
	}
	m.Call("setRepeatedSfixed64List", arr_________)

	arr__________ := js.Global.Get("Array").New(len(repeatedFloat))
	for i, value := range repeatedFloat {
		arr__________.SetIndex(i, value)
	}
	m.Call("setRepeatedFloatList", arr__________)

	arr___________ := js.Global.Get("Array").New(len(repeatedDouble))
	for i, value := range repeatedDouble {
		arr___________.SetIndex(i, value)
	}
	m.Call("setRepeatedDoubleList", arr___________)

	arr____________ := js.Global.Get("Array").New(len(repeatedBool))
	for i, value := range repeatedBool {
		arr____________.SetIndex(i, value)
	}
	m.Call("setRepeatedBoolList", arr____________)

	arr_____________ := js.Global.Get("Array").New(len(repeatedString))
	for i, value := range repeatedString {
		arr_____________.SetIndex(i, value)
	}
	m.Call("setRepeatedStringList", arr_____________)

	arr______________ := js.Global.Get("Array").New(len(repeatedBytes))
	for i, value := range repeatedBytes {
		arr______________.SetIndex(i, value)
	}
	m.Call("setRepeatedBytesList", arr______________)

	arr_______________ := js.Global.Get("Array").New(len(repeatedImportedMessage))
	for i, value := range repeatedImportedMessage {
		arr_______________.SetIndex(i, value)
	}
	m.Call("setRepeatedImportedMessageList", arr_______________)

	arr________________ := js.Global.Get("Array").New(len(repeatedNestedMessage))
	for i, value := range repeatedNestedMessage {
		arr________________.SetIndex(i, value)
	}
	m.Call("setRepeatedNestedMessageList", arr________________)

	arr_________________ := js.Global.Get("Array").New(len(repeatedForeignMessage))
	for i, value := range repeatedForeignMessage {
		arr_________________.SetIndex(i, value)
	}
	m.Call("setRepeatedForeignMessageList", arr_________________)

	arr__________________ := js.Global.Get("Array").New(len(repeatedNestedEnum))
	for i, value := range repeatedNestedEnum {
		arr__________________.SetIndex(i, value)
	}
	m.Call("setRepeatedNestedEnumList", arr__________________)

	arr___________________ := js.Global.Get("Array").New(len(repeatedForeignEnum))
	for i, value := range repeatedForeignEnum {
		arr___________________.SetIndex(i, value)
	}
	m.Call("setRepeatedForeignEnumList", arr___________________)

	return m
}

// Serialize marshals TestAllTypes to a slice of bytes.
func (m *TestAllTypes) Serialize() []byte {
	return jspb.Serialize(m)
}

// Deserialize unmarshals a TestAllTypes from a slice of bytes.
func (m *TestAllTypes) Deserialize(rawBytes []byte) (*TestAllTypes, error) {
	obj, err := jspb.Deserialize(js.Global.Get("proto").Get("types").Get("TestAllTypes"), rawBytes)
	if err != nil {
		return nil, err
	}

	return &TestAllTypes{
		Object: obj,
	}, nil
}

type TestAllTypes_NestedMessage struct {
	*js.Object
}

// GetB gets the B of the TestAllTypes_NestedMessage.
func (m *TestAllTypes_NestedMessage) GetB() (x int32) {
	if m == nil {
		return x
	}
	return int32(m.Call("getB").Int())
}

// SetB sets the B of the TestAllTypes_NestedMessage.
func (m *TestAllTypes_NestedMessage) SetB(v int32) {
	m.Call("setB", v)
}

// New creates a new TestAllTypes_NestedMessage.
func (m *TestAllTypes_NestedMessage) New(b int32) *TestAllTypes_NestedMessage {
	m = &TestAllTypes_NestedMessage{
		Object: js.Global.Get("proto").Get("types").Get("TestAllTypes").Get("NestedMessage").New([]interface{}{
			b,
		}),
	}

	return m
}

// Serialize marshals TestAllTypes_NestedMessage to a slice of bytes.
func (m *TestAllTypes_NestedMessage) Serialize() []byte {
	return jspb.Serialize(m)
}

// Deserialize unmarshals a TestAllTypes_NestedMessage from a slice of bytes.
func (m *TestAllTypes_NestedMessage) Deserialize(rawBytes []byte) (*TestAllTypes_NestedMessage, error) {
	obj, err := jspb.Deserialize(js.Global.Get("proto").Get("types").Get("TestAllTypes").Get("NestedMessage"), rawBytes)
	if err != nil {
		return nil, err
	}

	return &TestAllTypes_NestedMessage{
		Object: obj,
	}, nil
}

// This proto includes a recusively nested message.
type NestedTestAllTypes struct {
	*js.Object
}

// GetChild gets the Child of the NestedTestAllTypes.
func (m *NestedTestAllTypes) GetChild() (x *NestedTestAllTypes) {
	if m == nil {
		return x
	}
	return &NestedTestAllTypes{Object: m.Call("getChild")}
}

// SetChild sets the Child of the NestedTestAllTypes.
func (m *NestedTestAllTypes) SetChild(v *NestedTestAllTypes) {
	if v != nil {
		m.Call("setChild", v)
	} else {
		m.ClearChild()
	}
}

// HasChild indicates whether the Child of the NestedTestAllTypes is set.
func (m *NestedTestAllTypes) HasChild() bool {
	if m == nil {
		return false
	}
	return m.Call("hasChild").Bool()
}

// ClearChild clears the Child of the NestedTestAllTypes.
func (m *NestedTestAllTypes) ClearChild() {
	m.Call("clearChild")
}

// GetPayload gets the Payload of the NestedTestAllTypes.
func (m *NestedTestAllTypes) GetPayload() (x *TestAllTypes) {
	if m == nil {
		return x
	}
	return &TestAllTypes{Object: m.Call("getPayload")}
}

// SetPayload sets the Payload of the NestedTestAllTypes.
func (m *NestedTestAllTypes) SetPayload(v *TestAllTypes) {
	if v != nil {
		m.Call("setPayload", v)
	} else {
		m.ClearPayload()
	}
}

// HasPayload indicates whether the Payload of the NestedTestAllTypes is set.
func (m *NestedTestAllTypes) HasPayload() bool {
	if m == nil {
		return false
	}
	return m.Call("hasPayload").Bool()
}

// ClearPayload clears the Payload of the NestedTestAllTypes.
func (m *NestedTestAllTypes) ClearPayload() {
	m.Call("clearPayload")
}

// GetRepeatedChild gets the RepeatedChild of the NestedTestAllTypes.
// Warning: mutating the returned slice will not be reflected in the message.
// Use the setter to make changes to the slice in the message.
func (m *NestedTestAllTypes) GetRepeatedChild() (x []*NestedTestAllTypes) {
	if m == nil {
		return x
	}
	arrFunc := func(value *js.Object) {
		x = append(x, &NestedTestAllTypes{Object: value})
	}
	m.Call("getRepeatedChildList").Call("forEach", arrFunc)
	return x
}

// SetRepeatedChild sets the RepeatedChild of the NestedTestAllTypes.
func (m *NestedTestAllTypes) SetRepeatedChild(v []*NestedTestAllTypes) {
	arr := js.Global.Get("Array").New(len(v))
	for i, value := range v {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedChildList", arr)
}

// AddRepeatedChild adds an entry to the RepeatedChild slice of the NestedTestAllTypes
// at the specified index. If index is negative, inserts the element
// at the index counted from the end of the slice, with origin 1.
func (m *NestedTestAllTypes) AddRepeatedChild(v *NestedTestAllTypes, index int) {
	m.Call("addRepeatedChild", v, index)
}

// ClearRepeatedChild clears the RepeatedChild of the NestedTestAllTypes.
func (m *NestedTestAllTypes) ClearRepeatedChild() {
	m.Call("clearRepeatedChildList")
}

// New creates a new NestedTestAllTypes.
func (m *NestedTestAllTypes) New(child *NestedTestAllTypes, payload *TestAllTypes, repeatedChild []*NestedTestAllTypes) *NestedTestAllTypes {
	m = &NestedTestAllTypes{
		Object: js.Global.Get("proto").Get("types").Get("NestedTestAllTypes").New([]interface{}{
			js.Undefined,
			js.Undefined,
			js.Undefined,
		}),
	}

	m.SetChild(child)

	m.SetPayload(payload)

	arr := js.Global.Get("Array").New(len(repeatedChild))
	for i, value := range repeatedChild {
		arr.SetIndex(i, value)
	}
	m.Call("setRepeatedChildList", arr)

	return m
}

// Serialize marshals NestedTestAllTypes to a slice of bytes.
func (m *NestedTestAllTypes) Serialize() []byte {
	return jspb.Serialize(m)
}

// Deserialize unmarshals a NestedTestAllTypes from a slice of bytes.
func (m *NestedTestAllTypes) Deserialize(rawBytes []byte) (*NestedTestAllTypes, error) {
	obj, err := jspb.Deserialize(js.Global.Get("proto").Get("types").Get("NestedTestAllTypes"), rawBytes)
	if err != nil {
		return nil, err
	}

	return &NestedTestAllTypes{
		Object: obj,
	}, nil
}

// Define these after TestAllTypes to make sure the compiler can handle
// that.
type ForeignMessage struct {
	*js.Object
}

// GetC gets the C of the ForeignMessage.
func (m *ForeignMessage) GetC() (x int32) {
	if m == nil {
		return x
	}
	return int32(m.Call("getC").Int())
}

// SetC sets the C of the ForeignMessage.
func (m *ForeignMessage) SetC(v int32) {
	m.Call("setC", v)
}

// New creates a new ForeignMessage.
func (m *ForeignMessage) New(c int32) *ForeignMessage {
	m = &ForeignMessage{
		Object: js.Global.Get("proto").Get("types").Get("ForeignMessage").New([]interface{}{
			c,
		}),
	}

	return m
}

// Serialize marshals ForeignMessage to a slice of bytes.
func (m *ForeignMessage) Serialize() []byte {
	return jspb.Serialize(m)
}

// Deserialize unmarshals a ForeignMessage from a slice of bytes.
func (m *ForeignMessage) Deserialize(rawBytes []byte) (*ForeignMessage, error) {
	obj, err := jspb.Deserialize(js.Global.Get("proto").Get("types").Get("ForeignMessage"), rawBytes)
	if err != nil {
		return nil, err
	}

	return &ForeignMessage{
		Object: obj,
	}, nil
}

// Tests maps.
type TestMap struct {
	*js.Object
}

// GetMapInt32Int32 gets the MapInt32Int32 of the TestMap.
func (m *TestMap) GetMapInt32Int32() (x map[int32]int32) {
	if m == nil {
		return x
	}
	x = map[int32]int32{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = int32(value.Int())
	}
	m.Call("getMapInt32Int32Map").Call("forEach", mapFunc)
	return x
}

// SetMapInt32Int32 sets the MapInt32Int32 of the TestMap.
func (m *TestMap) SetMapInt32Int32(v map[int32]int32) {
	m.Call("clearMapInt32Int32Map")
	mp := m.Call("getMapInt32Int32Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapInt32Int32 clears the MapInt32Int32 of the TestMap.
func (m *TestMap) ClearMapInt32Int32() {
	m.Call("clearMapInt32Int32Map")
}

// GetMapInt64Int64 gets the MapInt64Int64 of the TestMap.
func (m *TestMap) GetMapInt64Int64() (x map[int64]int64) {
	if m == nil {
		return x
	}
	x = map[int64]int64{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[key.Int64()] = value.Int64()
	}
	m.Call("getMapInt64Int64Map").Call("forEach", mapFunc)
	return x
}

// SetMapInt64Int64 sets the MapInt64Int64 of the TestMap.
func (m *TestMap) SetMapInt64Int64(v map[int64]int64) {
	m.Call("clearMapInt64Int64Map")
	mp := m.Call("getMapInt64Int64Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapInt64Int64 clears the MapInt64Int64 of the TestMap.
func (m *TestMap) ClearMapInt64Int64() {
	m.Call("clearMapInt64Int64Map")
}

// GetMapUint32Uint32 gets the MapUint32Uint32 of the TestMap.
func (m *TestMap) GetMapUint32Uint32() (x map[uint32]uint32) {
	if m == nil {
		return x
	}
	x = map[uint32]uint32{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[uint32(key.Int())] = uint32(value.Int())
	}
	m.Call("getMapUint32Uint32Map").Call("forEach", mapFunc)
	return x
}

// SetMapUint32Uint32 sets the MapUint32Uint32 of the TestMap.
func (m *TestMap) SetMapUint32Uint32(v map[uint32]uint32) {
	m.Call("clearMapUint32Uint32Map")
	mp := m.Call("getMapUint32Uint32Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapUint32Uint32 clears the MapUint32Uint32 of the TestMap.
func (m *TestMap) ClearMapUint32Uint32() {
	m.Call("clearMapUint32Uint32Map")
}

// GetMapUint64Uint64 gets the MapUint64Uint64 of the TestMap.
func (m *TestMap) GetMapUint64Uint64() (x map[uint64]uint64) {
	if m == nil {
		return x
	}
	x = map[uint64]uint64{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[key.Uint64()] = value.Uint64()
	}
	m.Call("getMapUint64Uint64Map").Call("forEach", mapFunc)
	return x
}

// SetMapUint64Uint64 sets the MapUint64Uint64 of the TestMap.
func (m *TestMap) SetMapUint64Uint64(v map[uint64]uint64) {
	m.Call("clearMapUint64Uint64Map")
	mp := m.Call("getMapUint64Uint64Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapUint64Uint64 clears the MapUint64Uint64 of the TestMap.
func (m *TestMap) ClearMapUint64Uint64() {
	m.Call("clearMapUint64Uint64Map")
}

// GetMapSint32Sint32 gets the MapSint32Sint32 of the TestMap.
func (m *TestMap) GetMapSint32Sint32() (x map[int32]int32) {
	if m == nil {
		return x
	}
	x = map[int32]int32{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = int32(value.Int())
	}
	m.Call("getMapSint32Sint32Map").Call("forEach", mapFunc)
	return x
}

// SetMapSint32Sint32 sets the MapSint32Sint32 of the TestMap.
func (m *TestMap) SetMapSint32Sint32(v map[int32]int32) {
	m.Call("clearMapSint32Sint32Map")
	mp := m.Call("getMapSint32Sint32Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapSint32Sint32 clears the MapSint32Sint32 of the TestMap.
func (m *TestMap) ClearMapSint32Sint32() {
	m.Call("clearMapSint32Sint32Map")
}

// GetMapSint64Sint64 gets the MapSint64Sint64 of the TestMap.
func (m *TestMap) GetMapSint64Sint64() (x map[int64]int64) {
	if m == nil {
		return x
	}
	x = map[int64]int64{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[key.Int64()] = value.Int64()
	}
	m.Call("getMapSint64Sint64Map").Call("forEach", mapFunc)
	return x
}

// SetMapSint64Sint64 sets the MapSint64Sint64 of the TestMap.
func (m *TestMap) SetMapSint64Sint64(v map[int64]int64) {
	m.Call("clearMapSint64Sint64Map")
	mp := m.Call("getMapSint64Sint64Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapSint64Sint64 clears the MapSint64Sint64 of the TestMap.
func (m *TestMap) ClearMapSint64Sint64() {
	m.Call("clearMapSint64Sint64Map")
}

// GetMapFixed32Fixed32 gets the MapFixed32Fixed32 of the TestMap.
func (m *TestMap) GetMapFixed32Fixed32() (x map[uint32]uint32) {
	if m == nil {
		return x
	}
	x = map[uint32]uint32{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[uint32(key.Int())] = uint32(value.Int())
	}
	m.Call("getMapFixed32Fixed32Map").Call("forEach", mapFunc)
	return x
}

// SetMapFixed32Fixed32 sets the MapFixed32Fixed32 of the TestMap.
func (m *TestMap) SetMapFixed32Fixed32(v map[uint32]uint32) {
	m.Call("clearMapFixed32Fixed32Map")
	mp := m.Call("getMapFixed32Fixed32Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapFixed32Fixed32 clears the MapFixed32Fixed32 of the TestMap.
func (m *TestMap) ClearMapFixed32Fixed32() {
	m.Call("clearMapFixed32Fixed32Map")
}

// GetMapFixed64Fixed64 gets the MapFixed64Fixed64 of the TestMap.
func (m *TestMap) GetMapFixed64Fixed64() (x map[uint64]uint64) {
	if m == nil {
		return x
	}
	x = map[uint64]uint64{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[key.Uint64()] = value.Uint64()
	}
	m.Call("getMapFixed64Fixed64Map").Call("forEach", mapFunc)
	return x
}

// SetMapFixed64Fixed64 sets the MapFixed64Fixed64 of the TestMap.
func (m *TestMap) SetMapFixed64Fixed64(v map[uint64]uint64) {
	m.Call("clearMapFixed64Fixed64Map")
	mp := m.Call("getMapFixed64Fixed64Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapFixed64Fixed64 clears the MapFixed64Fixed64 of the TestMap.
func (m *TestMap) ClearMapFixed64Fixed64() {
	m.Call("clearMapFixed64Fixed64Map")
}

// GetMapSfixed32Sfixed32 gets the MapSfixed32Sfixed32 of the TestMap.
func (m *TestMap) GetMapSfixed32Sfixed32() (x map[int32]int32) {
	if m == nil {
		return x
	}
	x = map[int32]int32{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = int32(value.Int())
	}
	m.Call("getMapSfixed32Sfixed32Map").Call("forEach", mapFunc)
	return x
}

// SetMapSfixed32Sfixed32 sets the MapSfixed32Sfixed32 of the TestMap.
func (m *TestMap) SetMapSfixed32Sfixed32(v map[int32]int32) {
	m.Call("clearMapSfixed32Sfixed32Map")
	mp := m.Call("getMapSfixed32Sfixed32Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapSfixed32Sfixed32 clears the MapSfixed32Sfixed32 of the TestMap.
func (m *TestMap) ClearMapSfixed32Sfixed32() {
	m.Call("clearMapSfixed32Sfixed32Map")
}

// GetMapSfixed64Sfixed64 gets the MapSfixed64Sfixed64 of the TestMap.
func (m *TestMap) GetMapSfixed64Sfixed64() (x map[int64]int64) {
	if m == nil {
		return x
	}
	x = map[int64]int64{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[key.Int64()] = value.Int64()
	}
	m.Call("getMapSfixed64Sfixed64Map").Call("forEach", mapFunc)
	return x
}

// SetMapSfixed64Sfixed64 sets the MapSfixed64Sfixed64 of the TestMap.
func (m *TestMap) SetMapSfixed64Sfixed64(v map[int64]int64) {
	m.Call("clearMapSfixed64Sfixed64Map")
	mp := m.Call("getMapSfixed64Sfixed64Map")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapSfixed64Sfixed64 clears the MapSfixed64Sfixed64 of the TestMap.
func (m *TestMap) ClearMapSfixed64Sfixed64() {
	m.Call("clearMapSfixed64Sfixed64Map")
}

// GetMapInt32Float gets the MapInt32Float of the TestMap.
func (m *TestMap) GetMapInt32Float() (x map[int32]float32) {
	if m == nil {
		return x
	}
	x = map[int32]float32{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = float32(value.Float())
	}
	m.Call("getMapInt32FloatMap").Call("forEach", mapFunc)
	return x
}

// SetMapInt32Float sets the MapInt32Float of the TestMap.
func (m *TestMap) SetMapInt32Float(v map[int32]float32) {
	m.Call("clearMapInt32FloatMap")
	mp := m.Call("getMapInt32FloatMap")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapInt32Float clears the MapInt32Float of the TestMap.
func (m *TestMap) ClearMapInt32Float() {
	m.Call("clearMapInt32FloatMap")
}

// GetMapInt32Double gets the MapInt32Double of the TestMap.
func (m *TestMap) GetMapInt32Double() (x map[int32]float64) {
	if m == nil {
		return x
	}
	x = map[int32]float64{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = value.Float()
	}
	m.Call("getMapInt32DoubleMap").Call("forEach", mapFunc)
	return x
}

// SetMapInt32Double sets the MapInt32Double of the TestMap.
func (m *TestMap) SetMapInt32Double(v map[int32]float64) {
	m.Call("clearMapInt32DoubleMap")
	mp := m.Call("getMapInt32DoubleMap")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapInt32Double clears the MapInt32Double of the TestMap.
func (m *TestMap) ClearMapInt32Double() {
	m.Call("clearMapInt32DoubleMap")
}

// GetMapBoolBool gets the MapBoolBool of the TestMap.
func (m *TestMap) GetMapBoolBool() (x map[bool]bool) {
	if m == nil {
		return x
	}
	x = map[bool]bool{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[key.Bool()] = value.Bool()
	}
	m.Call("getMapBoolBoolMap").Call("forEach", mapFunc)
	return x
}

// SetMapBoolBool sets the MapBoolBool of the TestMap.
func (m *TestMap) SetMapBoolBool(v map[bool]bool) {
	m.Call("clearMapBoolBoolMap")
	mp := m.Call("getMapBoolBoolMap")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapBoolBool clears the MapBoolBool of the TestMap.
func (m *TestMap) ClearMapBoolBool() {
	m.Call("clearMapBoolBoolMap")
}

// GetMapStringString gets the MapStringString of the TestMap.
func (m *TestMap) GetMapStringString() (x map[string]string) {
	if m == nil {
		return x
	}
	x = map[string]string{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[key.String()] = value.String()
	}
	m.Call("getMapStringStringMap").Call("forEach", mapFunc)
	return x
}

// SetMapStringString sets the MapStringString of the TestMap.
func (m *TestMap) SetMapStringString(v map[string]string) {
	m.Call("clearMapStringStringMap")
	mp := m.Call("getMapStringStringMap")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapStringString clears the MapStringString of the TestMap.
func (m *TestMap) ClearMapStringString() {
	m.Call("clearMapStringStringMap")
}

// GetMapInt32Bytes gets the MapInt32Bytes of the TestMap.
func (m *TestMap) GetMapInt32Bytes() (x map[int32][]byte) {
	if m == nil {
		return x
	}
	x = map[int32][]byte{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = value.Interface().([]byte)
	}
	m.Call("getMapInt32BytesMap").Call("forEach", mapFunc)
	return x
}

// SetMapInt32Bytes sets the MapInt32Bytes of the TestMap.
func (m *TestMap) SetMapInt32Bytes(v map[int32][]byte) {
	m.Call("clearMapInt32BytesMap")
	mp := m.Call("getMapInt32BytesMap")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapInt32Bytes clears the MapInt32Bytes of the TestMap.
func (m *TestMap) ClearMapInt32Bytes() {
	m.Call("clearMapInt32BytesMap")
}

// GetMapInt32Enum gets the MapInt32Enum of the TestMap.
func (m *TestMap) GetMapInt32Enum() (x map[int32]MapEnum) {
	if m == nil {
		return x
	}
	x = map[int32]MapEnum{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = MapEnum(value.Int())
	}
	m.Call("getMapInt32EnumMap").Call("forEach", mapFunc)
	return x
}

// SetMapInt32Enum sets the MapInt32Enum of the TestMap.
func (m *TestMap) SetMapInt32Enum(v map[int32]MapEnum) {
	m.Call("clearMapInt32EnumMap")
	mp := m.Call("getMapInt32EnumMap")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapInt32Enum clears the MapInt32Enum of the TestMap.
func (m *TestMap) ClearMapInt32Enum() {
	m.Call("clearMapInt32EnumMap")
}

// GetMapInt32ForeignMessage gets the MapInt32ForeignMessage of the TestMap.
func (m *TestMap) GetMapInt32ForeignMessage() (x map[int32]*ForeignMessage) {
	if m == nil {
		return x
	}
	x = map[int32]*ForeignMessage{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = &ForeignMessage{Object: value}
	}
	m.Call("getMapInt32ForeignMessageMap").Call("forEach", mapFunc)
	return x
}

// SetMapInt32ForeignMessage sets the MapInt32ForeignMessage of the TestMap.
func (m *TestMap) SetMapInt32ForeignMessage(v map[int32]*ForeignMessage) {
	m.Call("clearMapInt32ForeignMessageMap")
	mp := m.Call("getMapInt32ForeignMessageMap")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapInt32ForeignMessage clears the MapInt32ForeignMessage of the TestMap.
func (m *TestMap) ClearMapInt32ForeignMessage() {
	m.Call("clearMapInt32ForeignMessageMap")
}

// GetMapInt32ImportedMessage gets the MapInt32ImportedMessage of the TestMap.
func (m *TestMap) GetMapInt32ImportedMessage() (x map[int32]*multitest2.Multi1) {
	if m == nil {
		return x
	}
	x = map[int32]*multitest2.Multi1{}
	mapFunc := func(value *js.Object, key *js.Object) {
		x[int32(key.Int())] = &multitest2.Multi1{Object: value}
	}
	m.Call("getMapInt32ImportedMessageMap").Call("forEach", mapFunc)
	return x
}

// SetMapInt32ImportedMessage sets the MapInt32ImportedMessage of the TestMap.
func (m *TestMap) SetMapInt32ImportedMessage(v map[int32]*multitest2.Multi1) {
	m.Call("clearMapInt32ImportedMessageMap")
	mp := m.Call("getMapInt32ImportedMessageMap")
	for key, value := range v {
		mp.Call("set", key, value)
	}
}

// ClearMapInt32ImportedMessage clears the MapInt32ImportedMessage of the TestMap.
func (m *TestMap) ClearMapInt32ImportedMessage() {
	m.Call("clearMapInt32ImportedMessageMap")
}

// New creates a new TestMap.
func (m *TestMap) New(mapInt32Int32 map[int32]int32, mapInt64Int64 map[int64]int64, mapUint32Uint32 map[uint32]uint32, mapUint64Uint64 map[uint64]uint64, mapSint32Sint32 map[int32]int32, mapSint64Sint64 map[int64]int64, mapFixed32Fixed32 map[uint32]uint32, mapFixed64Fixed64 map[uint64]uint64, mapSfixed32Sfixed32 map[int32]int32, mapSfixed64Sfixed64 map[int64]int64, mapInt32Float map[int32]float32, mapInt32Double map[int32]float64, mapBoolBool map[bool]bool, mapStringString map[string]string, mapInt32Bytes map[int32][]byte, mapInt32Enum map[int32]MapEnum, mapInt32ForeignMessage map[int32]*ForeignMessage, mapInt32ImportedMessage map[int32]*multitest2.Multi1) *TestMap {
	m = &TestMap{
		Object: js.Global.Get("proto").Get("types").Get("TestMap").New([]interface{}{
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
			js.Undefined,
		}),
	}

	mp := m.Call("getMapInt32Int32Map")
	for key, value := range mapInt32Int32 {
		mp.Call("set", key, value)
	}

	mp_ := m.Call("getMapInt64Int64Map")
	for key, value := range mapInt64Int64 {
		mp_.Call("set", key, value)
	}

	mp__ := m.Call("getMapUint32Uint32Map")
	for key, value := range mapUint32Uint32 {
		mp__.Call("set", key, value)
	}

	mp___ := m.Call("getMapUint64Uint64Map")
	for key, value := range mapUint64Uint64 {
		mp___.Call("set", key, value)
	}

	mp____ := m.Call("getMapSint32Sint32Map")
	for key, value := range mapSint32Sint32 {
		mp____.Call("set", key, value)
	}

	mp_____ := m.Call("getMapSint64Sint64Map")
	for key, value := range mapSint64Sint64 {
		mp_____.Call("set", key, value)
	}

	mp______ := m.Call("getMapFixed32Fixed32Map")
	for key, value := range mapFixed32Fixed32 {
		mp______.Call("set", key, value)
	}

	mp_______ := m.Call("getMapFixed64Fixed64Map")
	for key, value := range mapFixed64Fixed64 {
		mp_______.Call("set", key, value)
	}

	mp________ := m.Call("getMapSfixed32Sfixed32Map")
	for key, value := range mapSfixed32Sfixed32 {
		mp________.Call("set", key, value)
	}

	mp_________ := m.Call("getMapSfixed64Sfixed64Map")
	for key, value := range mapSfixed64Sfixed64 {
		mp_________.Call("set", key, value)
	}

	mp__________ := m.Call("getMapInt32FloatMap")
	for key, value := range mapInt32Float {
		mp__________.Call("set", key, value)
	}

	mp___________ := m.Call("getMapInt32DoubleMap")
	for key, value := range mapInt32Double {
		mp___________.Call("set", key, value)
	}

	mp____________ := m.Call("getMapBoolBoolMap")
	for key, value := range mapBoolBool {
		mp____________.Call("set", key, value)
	}

	mp_____________ := m.Call("getMapStringStringMap")
	for key, value := range mapStringString {
		mp_____________.Call("set", key, value)
	}

	mp______________ := m.Call("getMapInt32BytesMap")
	for key, value := range mapInt32Bytes {
		mp______________.Call("set", key, value)
	}

	mp_______________ := m.Call("getMapInt32EnumMap")
	for key, value := range mapInt32Enum {
		mp_______________.Call("set", key, value)
	}

	mp________________ := m.Call("getMapInt32ForeignMessageMap")
	for key, value := range mapInt32ForeignMessage {
		mp________________.Call("set", key, value)
	}

	mp_________________ := m.Call("getMapInt32ImportedMessageMap")
	for key, value := range mapInt32ImportedMessage {
		mp_________________.Call("set", key, value)
	}

	return m
}

// Serialize marshals TestMap to a slice of bytes.
func (m *TestMap) Serialize() []byte {
	return jspb.Serialize(m)
}

// Deserialize unmarshals a TestMap from a slice of bytes.
func (m *TestMap) Deserialize(rawBytes []byte) (*TestMap, error) {
	obj, err := jspb.Deserialize(js.Global.Get("proto").Get("types").Get("TestMap"), rawBytes)
	if err != nil {
		return nil, err
	}

	return &TestMap{
		Object: obj,
	}, nil
}
