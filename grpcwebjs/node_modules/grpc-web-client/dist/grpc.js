"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var browser_headers_1 = require("browser-headers");
exports.BrowserHeaders = browser_headers_1.BrowserHeaders;
var ChunkParser_1 = require("./ChunkParser");
var Transport_1 = require("./transports/Transport");
var debug_1 = require("./debug");
var grpc;
(function (grpc) {
    var Code;
    (function (Code) {
        Code[Code["OK"] = 0] = "OK";
        Code[Code["Canceled"] = 1] = "Canceled";
        Code[Code["Unknown"] = 2] = "Unknown";
        Code[Code["InvalidArgument"] = 3] = "InvalidArgument";
        Code[Code["DeadlineExceeded"] = 4] = "DeadlineExceeded";
        Code[Code["NotFound"] = 5] = "NotFound";
        Code[Code["AlreadyExists"] = 6] = "AlreadyExists";
        Code[Code["PermissionDenied"] = 7] = "PermissionDenied";
        Code[Code["ResourceExhausted"] = 8] = "ResourceExhausted";
        Code[Code["FailedPrecondition"] = 9] = "FailedPrecondition";
        Code[Code["Aborted"] = 10] = "Aborted";
        Code[Code["OutOfRange"] = 11] = "OutOfRange";
        Code[Code["Unimplemented"] = 12] = "Unimplemented";
        Code[Code["Internal"] = 13] = "Internal";
        Code[Code["Unavailable"] = 14] = "Unavailable";
        Code[Code["DataLoss"] = 15] = "DataLoss";
        Code[Code["Unauthenticated"] = 16] = "Unauthenticated";
    })(Code = grpc.Code || (grpc.Code = {}));
    function httpStatusToCode(httpStatus) {
        switch (httpStatus) {
            case 0:
                return Code.Internal;
            case 200:
                return Code.OK;
            case 400:
                return Code.InvalidArgument;
            case 401:
                return Code.Unauthenticated;
            case 403:
                return Code.PermissionDenied;
            case 404:
                return Code.NotFound;
            case 409:
                return Code.Aborted;
            case 412:
                return Code.FailedPrecondition;
            case 429:
                return Code.ResourceExhausted;
            case 499:
                return Code.Canceled;
            case 500:
                return Code.Unknown;
            case 501:
                return Code.Unimplemented;
            case 503:
                return Code.Unavailable;
            case 504:
                return Code.DeadlineExceeded;
            default:
                return Code.Unknown;
        }
    }
    function frameRequest(request) {
        var bytes = request.serializeBinary();
        var frame = new ArrayBuffer(bytes.byteLength + 5);
        new DataView(frame, 1, 4).setUint32(0, bytes.length, false);
        new Uint8Array(frame, 5).set(bytes);
        return new Uint8Array(frame);
    }
    function getStatusFromHeaders(headers) {
        var fromHeaders = headers.get("grpc-status") || [];
        if (fromHeaders.length > 0) {
            try {
                var asString = fromHeaders[0];
                return parseInt(asString, 10);
            }
            catch (e) {
                return Code.Internal;
            }
        }
        return Code.Internal;
    }
    function invoke(methodDescriptor, props) {
        var requestHeaders = new browser_headers_1.BrowserHeaders(props.headers ? props.headers : {});
        requestHeaders.set("content-type", "application/grpc-web");
        requestHeaders.set("x-grpc-web", "1");
        var framedRequest = frameRequest(props.request);
        var completed = false;
        function rawOnEnd(code, message, trailers) {
            if (completed)
                return;
            completed = true;
            props.onEnd(code, message, trailers);
        }
        function rawOnHeaders(headers) {
            if (completed)
                return;
            if (props.onHeaders) {
                props.onHeaders(headers);
            }
        }
        function rawOnError(code, msg) {
            if (completed)
                return;
            completed = true;
            props.onEnd(code, msg, new browser_headers_1.BrowserHeaders());
        }
        function rawOnMessage(res) {
            if (completed)
                return;
            if (props.onMessage) {
                props.onMessage(res);
            }
        }
        var responseHeaders;
        var responseTrailers;
        var parser = new ChunkParser_1.ChunkParser();
        var transport = props.transport;
        if (!transport) {
            transport = Transport_1.DefaultTransportFactory.getTransport();
        }
        transport({
            debug: props.debug || false,
            url: props.host + "/" + methodDescriptor.service.serviceName + "/" + methodDescriptor.methodName,
            headers: requestHeaders,
            body: framedRequest,
            onHeaders: function (headers, status) {
                props.debug && debug_1.debug("onHeaders", headers, status);
                if (status === 0) {
                }
                else {
                    responseHeaders = headers;
                    props.debug && debug_1.debug("onHeaders.responseHeaders", JSON.stringify(responseHeaders, null, 2));
                    var code = httpStatusToCode(status);
                    props.debug && debug_1.debug("onHeaders.code", code);
                    var gRPCMessage = headers.get("grpc-message") || [];
                    props.debug && debug_1.debug("onHeaders.gRPCMessage", gRPCMessage);
                    if (code !== Code.OK) {
                        rawOnError(code, gRPCMessage[0] || "");
                        return;
                    }
                    rawOnHeaders(headers);
                }
            },
            onChunk: function (chunkBytes) {
                var data = [];
                try {
                    data = parser.parse(chunkBytes);
                }
                catch (e) {
                    props.debug && debug_1.debug("onChunk.parsing error", e, e.message);
                    rawOnError(Code.Internal, "parsing error: " + e.message);
                    return;
                }
                data.forEach(function (d) {
                    if (d.chunkType === ChunkParser_1.ChunkType.MESSAGE) {
                        var deserialized = methodDescriptor.responseType.deserializeBinary(d.data);
                        rawOnMessage(deserialized);
                    }
                    else if (d.chunkType === ChunkParser_1.ChunkType.TRAILERS) {
                        props.debug && debug_1.debug("onChunk.trailers", responseTrailers);
                        responseTrailers = new browser_headers_1.BrowserHeaders(d.trailers);
                    }
                });
            },
            onEnd: function () {
                props.debug && debug_1.debug("grpc.onEnd");
                if (responseTrailers === undefined) {
                    if (responseHeaders === undefined) {
                        rawOnError(Code.Internal, "Response closed without headers");
                        return;
                    }
                    var grpcStatus_1 = getStatusFromHeaders(responseHeaders);
                    var grpcMessage_1 = responseHeaders.get("grpc-message");
                    props.debug && debug_1.debug("grpc.headers only response ", grpcStatus_1, grpcMessage_1);
                    rawOnEnd(grpcStatus_1, grpcMessage_1[0] || "Response closed without grpc-status (Headers only)", responseHeaders);
                    return;
                }
                var grpcStatus = getStatusFromHeaders(responseTrailers);
                if (grpcStatus === null) {
                    rawOnError(Code.Internal, "Response closed without grpc-status (Trailers provided)");
                    return;
                }
                var grpcMessage = responseTrailers.get("grpc-message");
                rawOnEnd(grpcStatus, grpcMessage ? grpcMessage[0] : "", responseTrailers);
            }
        });
    }
    grpc.invoke = invoke;
})(grpc = exports.grpc || (exports.grpc = {}));
//# sourceMappingURL=grpc.js.map