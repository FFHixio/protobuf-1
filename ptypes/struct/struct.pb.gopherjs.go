// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: struct/struct.proto

/*
	Package structpb is a generated protocol buffer package.

	It is generated from these files:
		struct/struct.proto

	It has these top-level messages:
		Struct
		Value
		ListValue
*/
package structpb

import jspb "github.com/johanbrandhorst/protobuf/jspb"

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// `NullValue` is a singleton enumeration to represent the null value for the
// `Value` type union.
//
//  The JSON representation for `NullValue` is JSON `null`.
type NullValue int

const (
	// Null value.
	NullValue_NULL_VALUE NullValue = 0
)

var NullValue_name = map[int]string{
	0: "NULL_VALUE",
}
var NullValue_value = map[string]int{
	"NULL_VALUE": 0,
}

func (x NullValue) String() string {
	return NullValue_name[int(x)]
}

// `Struct` represents a structured data value, consisting of fields
// which map to dynamically typed values. In some languages, `Struct`
// might be supported by a native representation. For example, in
// scripting languages like JS a struct is represented as an
// object. The details of that representation are described together
// with the proto support for the language.
//
// The JSON representation for `Struct` is JSON object.
type Struct struct {
	// Unordered map of dynamically typed values.
	Fields map[string]*Value
}

// GetFields gets the Fields of the Struct.
func (m *Struct) GetFields() (x map[string]*Value) {
	if m == nil {
		return x
	}
	return m.Fields
}

// MarshalToWriter marshals Struct to the provided writer.
func (m *Struct) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Fields) > 0 {
		for key, value := range m.Fields {
			writer.WriteMessage(1, func() {
				writer.WriteString(1, key)
				writer.WriteMessage(2, func() {
					value.MarshalToWriter(writer)
				})
			})
		}
	}

	return
}

// Marshal marshals Struct to a slice of bytes.
func (m *Struct) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Struct from the provided reader.
func (m *Struct) UnmarshalFromReader(reader jspb.Reader) *Struct {
	for reader.Next() {
		if m == nil {
			m = &Struct{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			if m.Fields == nil {
				m.Fields = map[string]*Value{}
			}
			reader.ReadMessage(func() {
				var key string
				var value *Value
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadString()
					case 2:
						reader.ReadMessage(func() {
							value = new(Value).UnmarshalFromReader(reader)
						})
					}
					m.Fields[key] = value
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Struct from a slice of bytes.
func (m *Struct) Unmarshal(rawBytes []byte) (*Struct, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// `Value` represents a dynamically typed value which can be either
// null, a number, a string, a boolean, a recursive struct value, or a
// list of values. A producer of value is expected to set one of that
// variants, absence of any variant indicates an error.
//
// The JSON representation for `Value` is JSON value.
type Value struct {
	// Represents a null value.
	// The kind of value.
	//
	// Types that are valid to be assigned to Kind:
	//	*Value_NullValue
	//	*Value_NumberValue
	//	*Value_StringValue
	//	*Value_BoolValue
	//	*Value_StructValue
	//	*Value_ListValue
	Kind isValue_Kind
	// Represents a double value.
	// Represents a string value.
	// Represents a boolean value.
	// Represents a structured value.
	// Represents a repeated `Value`.
}

// isValue_Kind is used to distinguish types assignable to Kind
type isValue_Kind interface {
	isValue_Kind()
}

// Value_NullValue is assignable to Kind
type Value_NullValue struct {
	// Represents a null value.
	NullValue NullValue
}

// Value_NumberValue is assignable to Kind
type Value_NumberValue struct {
	// Represents a double value.
	NumberValue float64
}

// Value_StringValue is assignable to Kind
type Value_StringValue struct {
	// Represents a string value.
	StringValue string
}

// Value_BoolValue is assignable to Kind
type Value_BoolValue struct {
	// Represents a boolean value.
	BoolValue bool
}

// Value_StructValue is assignable to Kind
type Value_StructValue struct {
	// Represents a structured value.
	StructValue *Struct
}

// Value_ListValue is assignable to Kind
type Value_ListValue struct {
	// Represents a repeated `Value`.
	ListValue *ListValue
}

func (*Value_NullValue) isValue_Kind()   {}
func (*Value_NumberValue) isValue_Kind() {}
func (*Value_StringValue) isValue_Kind() {}
func (*Value_BoolValue) isValue_Kind()   {}
func (*Value_StructValue) isValue_Kind() {}
func (*Value_ListValue) isValue_Kind()   {}

// GetKind gets the Kind of the Value.
func (m *Value) GetKind() (x isValue_Kind) {
	if m == nil {
		return x
	}
	return m.Kind
}

// GetNullValue gets the NullValue of the Value.
func (m *Value) GetNullValue() (x NullValue) {
	if v, ok := m.GetKind().(*Value_NullValue); ok {
		return v.NullValue
	}
	return x
}

// GetNumberValue gets the NumberValue of the Value.
func (m *Value) GetNumberValue() (x float64) {
	if v, ok := m.GetKind().(*Value_NumberValue); ok {
		return v.NumberValue
	}
	return x
}

// GetStringValue gets the StringValue of the Value.
func (m *Value) GetStringValue() (x string) {
	if v, ok := m.GetKind().(*Value_StringValue); ok {
		return v.StringValue
	}
	return x
}

// GetBoolValue gets the BoolValue of the Value.
func (m *Value) GetBoolValue() (x bool) {
	if v, ok := m.GetKind().(*Value_BoolValue); ok {
		return v.BoolValue
	}
	return x
}

// GetStructValue gets the StructValue of the Value.
func (m *Value) GetStructValue() (x *Struct) {
	if v, ok := m.GetKind().(*Value_StructValue); ok {
		return v.StructValue
	}
	return x
}

// GetListValue gets the ListValue of the Value.
func (m *Value) GetListValue() (x *ListValue) {
	if v, ok := m.GetKind().(*Value_ListValue); ok {
		return v.ListValue
	}
	return x
}

// MarshalToWriter marshals Value to the provided writer.
func (m *Value) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	switch t := m.Kind.(type) {
	case *Value_NullValue:
		if int(t.NullValue) != 0 {
			writer.WriteEnum(1, int(t.NullValue))
		}
	case *Value_NumberValue:
		if t.NumberValue != 0 {
			writer.WriteFloat64(2, t.NumberValue)
		}
	case *Value_StringValue:
		if len(t.StringValue) > 0 {
			writer.WriteString(3, t.StringValue)
		}
	case *Value_BoolValue:
		if t.BoolValue {
			writer.WriteBool(4, t.BoolValue)
		}
	case *Value_StructValue:
		if t.StructValue != nil {
			writer.WriteMessage(5, func() {
				t.StructValue.MarshalToWriter(writer)
			})
		}
	case *Value_ListValue:
		if t.ListValue != nil {
			writer.WriteMessage(6, func() {
				t.ListValue.MarshalToWriter(writer)
			})
		}
	}

	return
}

// Marshal marshals Value to a slice of bytes.
func (m *Value) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Value from the provided reader.
func (m *Value) UnmarshalFromReader(reader jspb.Reader) *Value {
	for reader.Next() {
		if m == nil {
			m = &Value{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Kind = &Value_NullValue{
				NullValue: NullValue(reader.ReadEnum()),
			}
		case 2:
			m.Kind = &Value_NumberValue{
				NumberValue: reader.ReadFloat64(),
			}
		case 3:
			m.Kind = &Value_StringValue{
				StringValue: reader.ReadString(),
			}
		case 4:
			m.Kind = &Value_BoolValue{
				BoolValue: reader.ReadBool(),
			}
		case 5:
			reader.ReadMessage(func() {
				m.Kind = &Value_StructValue{
					StructValue: new(Struct).UnmarshalFromReader(reader),
				}
			})
		case 6:
			reader.ReadMessage(func() {
				m.Kind = &Value_ListValue{
					ListValue: new(ListValue).UnmarshalFromReader(reader),
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Value from a slice of bytes.
func (m *Value) Unmarshal(rawBytes []byte) (*Value, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// `ListValue` is a wrapper around a repeated field of values.
//
// The JSON representation for `ListValue` is JSON array.
type ListValue struct {
	// Repeated field of dynamically typed values.
	Values []*Value
}

// GetValues gets the Values of the ListValue.
func (m *ListValue) GetValues() (x []*Value) {
	if m == nil {
		return x
	}
	return m.Values
}

// MarshalToWriter marshals ListValue to the provided writer.
func (m *ListValue) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, msg := range m.Values {
		writer.WriteMessage(1, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals ListValue to a slice of bytes.
func (m *ListValue) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ListValue from the provided reader.
func (m *ListValue) UnmarshalFromReader(reader jspb.Reader) *ListValue {
	for reader.Next() {
		if m == nil {
			m = &ListValue{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Values = append(m.Values, new(Value).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ListValue from a slice of bytes.
func (m *ListValue) Unmarshal(rawBytes []byte) (*ListValue, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}
